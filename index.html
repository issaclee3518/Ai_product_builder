<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>화이트보드 메모장</title>
  <meta name="description" content="그림판처럼 그릴 수 있고 텍스트 메모를 남길 수 있는 전체 화면 화이트보드입니다." />
  <meta name="robots" content="index,follow" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <style>
    :root {
      color-scheme: light;
      --bg: #f2f5fb;
      --board: #ffffff;
      --ink: #1f2933;
      --ink-muted: #52606d;
      --accent: #2563eb;
      --accent-soft: rgba(37, 99, 235, 0.12);
      --border: #d9e2ec;
      --shadow: 0 24px 60px rgba(15, 23, 42, 0.14);
      font-family: "Pretendard", "Noto Sans KR", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--ink);
      display: flex;
    }
    .app {
      display: flex;
      flex-direction: column;
      width: 100%;
      min-height: 100vh;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      padding: 18px clamp(16px, 4vw, 32px);
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(18px);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .toolbar-left {
      display: flex;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 18px;
    }
    .toolbar-left span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-size: 18px;
      box-shadow: 0 12px 30px rgba(37, 99, 235, 0.28);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .controls label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--ink-muted);
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.85);
    }
    .controls input[type="color"] {
      appearance: none;
      border: none;
      width: 32px;
      height: 24px;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
    }
    .controls input[type="range"] {
      width: 110px;
      accent-color: var(--accent);
    }
    .mode-toggle {
      display: inline-flex;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.9);
      overflow: hidden;
    }
    .mode-toggle button {
      all: unset;
      padding: 10px 16px;
      font-size: 13px;
      font-weight: 600;
      color: var(--ink-muted);
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
    }
    .mode-toggle button.active {
      background: var(--accent);
      color: #fff;
    }
    .pill-button {
      all: unset;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 10px 18px;
      font-size: 13px;
      font-weight: 600;
      border-radius: 999px;
      color: var(--accent);
      cursor: pointer;
      border: 1px solid rgba(37, 99, 235, 0.2);
      background: rgba(37, 99, 235, 0.08);
      transition: transform 0.15s;
    }
    .pill-button:hover { transform: translateY(-1px); }
    .pill-button.danger {
      color: #d61f4a;
      border-color: rgba(214, 31, 74, 0.18);
      background: rgba(214, 31, 74, 0.08);
    }
    .share-wrapper {
      position: relative;
    }
    .share-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
    }
    .share-button svg {
      width: 16px;
      height: 16px;
    }
    .share-menu {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      min-width: 180px;
      background: #ffffff;
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: 0 18px 34px rgba(15, 23, 42, 0.18);
      padding: 6px;
      display: none;
      z-index: 20;
    }
    .share-menu.open {
      display: block;
    }
    .share-menu button {
      all: unset;
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      color: var(--ink-muted);
      transition: background 0.15s, color 0.15s;
    }
    .share-menu button:hover {
      background: rgba(37, 99, 235, 0.08);
      color: var(--accent);
    }
    #board {
      position: relative;
      flex: 1;
      margin: clamp(12px, 4vw, 24px);
      border-radius: 28px;
      background: var(--board);
      box-shadow: var(--shadow);
      overflow: hidden;
      border: 1px solid var(--border);
    }
    #board:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }
    #board-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
      cursor: crosshair;
    }
    #text-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #text-layer.editable .text-note { pointer-events: auto; }
    .text-note {
      position: absolute;
      min-width: 180px;
      min-height: 120px;
      background: rgba(255, 255, 255, 0.92);
      border: 1px solid rgba(15, 23, 42, 0.12);
      border-radius: 16px;
      box-shadow: 0 16px 36px rgba(15, 23, 42, 0.18);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      pointer-events: auto;
      transition: box-shadow 0.2s;
    }
    .text-note:focus-within {
      box-shadow: 0 18px 40px rgba(37, 99, 235, 0.28);
      border-color: rgba(37, 99, 235, 0.28);
    }
    .note-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(37, 99, 235, 0.08);
      border-bottom: 1px solid rgba(37, 99, 235, 0.12);
    }
    .note-handle,
    .note-delete {
      all: unset;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 16px;
      cursor: grab;
    }
    .note-handle:active { cursor: grabbing; }
    .note-delete {
      color: #c81e1e;
      cursor: pointer;
    }
    .note-body {
      flex: 1;
      padding: 10px 12px;
      color: var(--ink);
      font-size: 15px;
      line-height: 1.5;
      outline: none;
      overflow: auto;
      word-break: break-word;
    }
    .note-body:empty::before {
      content: attr(data-placeholder);
      color: var(--ink-muted);
      opacity: 0.65;
    }
    .empty-hint {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: clamp(18px, 3vw, 24px);
      color: rgba(15, 23, 42, 0.28);
      pointer-events: none;
      padding: 0 24px;
    }
    #text-layer:not(:empty) + .empty-hint,
    .drawing-made + #text-layer + .empty-hint {
      display: none;
    }
    @media (max-width: 720px) {
      .toolbar {
        justify-content: center;
        gap: 16px;
      }
      .toolbar-left {
        width: 100%;
        justify-content: center;
      }
      .controls {
        justify-content: center;
      }
      #board {
        margin: 12px;
        border-radius: 20px;
      }
      .mode-toggle button {
        padding: 9px 14px;
        font-size: 12px;
      }
      .controls label {
        font-size: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="toolbar" aria-label="화이트보드 도구 막대">
      <div class="toolbar-left">
        <span>✎</span>
        메모 화이트보드
      </div>
      <div class="controls">
        <div class="mode-toggle" role="group" aria-label="모드 선택">
          <button type="button" data-mode="draw" class="active">그리기</button>
          <button type="button" data-mode="text">텍스트</button>
          <button type="button" data-mode="erase">지우개</button>
        </div>
        <label>색상
          <input type="color" id="color-picker" value="#1f2933" aria-label="선 색상 선택" />
        </label>
        <label>두께
          <input type="range" id="thickness" min="1" max="50" value="6" aria-label="선 두께 조절" />
        </label>
        <div class="share-wrapper">
          <button type="button" class="pill-button share-button" id="share-button" aria-haspopup="true" aria-expanded="false">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path fill="currentColor" d="M18 16a3 3 0 0 0-2.141.908l-6.18-3.09a3 3 0 0 0 0-2.636l6.18-3.09A3 3 0 1 0 15 6a2.96 2.96 0 0 0 .205 1.07L9.026 10.16a3 3 0 1 0 0 3.68l6.179 3.09A3 3 0 1 0 18 16Zm0-11a1 1 0 1 1-1 1 1 1 0 0 1 1-1ZM6 14a1 1 0 1 1 1-1 1 1 0 0 1-1 1Zm12 6a1 1 0 1 1 1-1 1 1 0 0 1-1 1Z"/>
            </svg>
            공유하기
          </button>
          <div class="share-menu" id="share-menu" role="menu" aria-label="공유 대상 선택">
            <button type="button" data-share="instagram" role="menuitem">인스타그램으로 공유</button>
            <button type="button" data-share="kakao" role="menuitem">카카오톡으로 공유</button>
            <button type="button" data-share="twitter" role="menuitem">트위터로 공유</button>
          </div>
        </div>
        <button type="button" class="pill-button danger" id="clear-board">전체 지우기</button>
        <button type="button" class="pill-button" id="download-board">이미지 저장</button>
      </div>
    </header>
    <main id="board" tabindex="0" aria-label="그리기와 메모를 위한 화이트보드 영역">
      <canvas id="board-canvas"></canvas>
      <div id="text-layer"></div>
      <div class="empty-hint">➕ 상단에서 모드를 선택해 그림을 그리거나, 텍스트 모드에서 보드 위를 클릭해 메모를 추가해 보세요.</div>
    </main>
  </div>
  <script>
    (function() {
      const canvas = document.getElementById("board-canvas");
      const ctx = canvas.getContext("2d");
      const board = document.getElementById("board");
      const colorPicker = document.getElementById("color-picker");
      const thicknessInput = document.getElementById("thickness");
      const modeButtons = document.querySelectorAll(".mode-toggle button");
      const clearButton = document.getElementById("clear-board");
      const downloadButton = document.getElementById("download-board");
      const textLayer = document.getElementById("text-layer");
      const dpr = window.devicePixelRatio || 1;

      let mode = "draw";
      let drawing = false;
      let lastX = 0;
      let lastY = 0;
      let strokeColor = colorPicker.value;
      let strokeWidth = Number(thicknessInput.value);
      let drawingMade = false;

      const setMode = (nextMode) => {
        mode = nextMode;
        modeButtons.forEach(btn => btn.classList.toggle("active", btn.dataset.mode === mode));
        if (mode === "text") {
          textLayer.classList.add("editable");
          board.style.cursor = "text";
        } else {
          textLayer.classList.remove("editable");
          board.style.cursor = "crosshair";
        }
      };

      modeButtons.forEach(button => {
        button.addEventListener("click", () => setMode(button.dataset.mode));
      });

      colorPicker.addEventListener("input", (event) => {
        strokeColor = event.target.value;
      });

      thicknessInput.addEventListener("input", (event) => {
        strokeWidth = Number(event.target.value);
      });

      const resizeCanvas = () => {
        const rect = board.getBoundingClientRect();
        const snapshot = canvas.toDataURL();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + "px";
        canvas.style.height = rect.height + "px";
        ctx.resetTransform();
        ctx.scale(dpr, dpr);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        if (snapshot && snapshot !== "data:,") {
          const img = new Image();
          img.onload = () => ctx.drawImage(img, 0, 0, rect.width, rect.height);
          img.src = snapshot;
        } else {
          ctx.clearRect(0, 0, rect.width, rect.height);
        }
      };

      const getRelativePosition = (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        return { x, y };
      };

      const startDrawing = (event) => {
        if (mode === "draw" || mode === "erase") {
          drawing = true;
          canvas.setPointerCapture(event.pointerId);
          const { x, y } = getRelativePosition(event);
          lastX = x;
          lastY = y;
          ctx.beginPath();
          ctx.moveTo(x, y);
          draw(event);
        }
      };

      const draw = (event) => {
        if (!drawing) return;
        const { x, y } = getRelativePosition(event);
        ctx.lineWidth = mode === "erase" ? strokeWidth * 2 : strokeWidth;
        ctx.globalCompositeOperation = mode === "erase" ? "destination-out" : "source-over";
        ctx.strokeStyle = mode === "erase" ? "rgba(0,0,0,1)" : strokeColor;
        ctx.lineTo(x, y);
        ctx.stroke();
        lastX = x;
        lastY = y;
        drawingMade = true;
        canvas.classList.add("drawing-made");
      };

      const stopDrawing = (event) => {
        if (!drawing) return;
        drawing = false;
        canvas.releasePointerCapture(event.pointerId);
        ctx.closePath();
      };

      canvas.addEventListener("pointerdown", startDrawing);
      canvas.addEventListener("pointermove", draw);
      canvas.addEventListener("pointerup", stopDrawing);
      canvas.addEventListener("pointercancel", stopDrawing);
      canvas.addEventListener("pointerleave", stopDrawing);

      const boardClick = (event) => {
        if (mode !== "text") return;
        if (event.target.closest(".text-note")) return;
        const boardRect = board.getBoundingClientRect();
        const x = event.clientX - boardRect.left;
        const y = event.clientY - boardRect.top;
        createTextNote(x, y);
      };

      board.addEventListener("pointerdown", boardClick);

      let draggingNote = null;
      let dragOffsetX = 0;
      let dragOffsetY = 0;

      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      const startDraggingNote = (event) => {
        const note = event.currentTarget.closest(".text-note");
        draggingNote = note;
        const noteRect = note.getBoundingClientRect();
        const boardRect = board.getBoundingClientRect();
        dragOffsetX = event.clientX - noteRect.left;
        dragOffsetY = event.clientY - noteRect.top;
        note.setPointerCapture(event.pointerId);
        note.addEventListener("pointermove", dragNote);
        note.addEventListener("pointerup", stopDraggingNote, { once: true });
        note.addEventListener("pointercancel", stopDraggingNote, { once: true });
        event.preventDefault();
        event.stopPropagation();
      };

      const dragNote = (event) => {
        if (!draggingNote) return;
        const boardRect = board.getBoundingClientRect();
        const maxX = boardRect.width - draggingNote.offsetWidth;
        const maxY = boardRect.height - draggingNote.offsetHeight;
        const x = clamp(event.clientX - boardRect.left - dragOffsetX, 0, Math.max(0, maxX));
        const y = clamp(event.clientY - boardRect.top - dragOffsetY, 0, Math.max(0, maxY));
        draggingNote.style.left = `${x}px`;
        draggingNote.style.top = `${y}px`;
      };

      const stopDraggingNote = (event) => {
        if (!draggingNote) return;
        draggingNote.releasePointerCapture(event.pointerId);
        draggingNote.removeEventListener("pointermove", dragNote);
        draggingNote = null;
      };

      const createTextNote = (x, y) => {
        const boardRect = board.getBoundingClientRect();
        const note = document.createElement("div");
        note.className = "text-note";
        note.style.left = `${clamp(x - 90, 0, Math.max(0, boardRect.width - 200))}px`;
        note.style.top = `${clamp(y - 40, 0, Math.max(0, boardRect.height - 140))}px`;

        const header = document.createElement("div");
        header.className = "note-header";

        const handle = document.createElement("button");
        handle.type = "button";
        handle.className = "note-handle";
        handle.setAttribute("aria-label", "메모 이동");
        handle.textContent = "⠿";
        handle.addEventListener("pointerdown", startDraggingNote);

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "note-delete";
        deleteBtn.setAttribute("aria-label", "메모 삭제");
        deleteBtn.textContent = "×";
        deleteBtn.addEventListener("click", () => note.remove());

        header.append(handle, deleteBtn);

        const body = document.createElement("div");
        body.className = "note-body";
        body.contentEditable = "true";
        body.setAttribute("role", "textbox");
        body.setAttribute("aria-multiline", "true");
        body.setAttribute("spellcheck", "true");
        body.dataset.placeholder = "메모를 입력하세요";
        body.addEventListener("keydown", (event) => {
          if (event.key === "Escape") {
            body.blur();
          }
        });

        note.append(header, body);
        textLayer.appendChild(note);
        requestAnimationFrame(() => body.focus());
      };

      clearButton.addEventListener("click", () => {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        textLayer.innerHTML = "";
        drawingMade = false;
        canvas.classList.remove("drawing-made");
      });

      const buildExportCanvas = () => {
        const boardRect = board.getBoundingClientRect();
        const exportCanvas = document.createElement("canvas");
        exportCanvas.width = canvas.width;
        exportCanvas.height = canvas.height;
        const exportCtx = exportCanvas.getContext("2d");
        exportCtx.drawImage(canvas, 0, 0);

        const notes = textLayer.querySelectorAll(".text-note");
        notes.forEach((note) => {
          const body = note.querySelector(".note-body");
          const noteRect = note.getBoundingClientRect();
          const x = (noteRect.left - boardRect.left) * dpr;
          const y = (noteRect.top - boardRect.top) * dpr;
          const width = noteRect.width * dpr;
          const height = noteRect.height * dpr;

          exportCtx.save();
          exportCtx.globalAlpha = 0.94;
          exportCtx.fillStyle = "#ffffff";
          exportCtx.strokeStyle = "rgba(15, 23, 42, 0.12)";
          exportCtx.lineWidth = 2;
          exportCtx.beginPath();
          const radius = 16 * dpr;
          exportCtx.moveTo(x + radius, y);
          exportCtx.lineTo(x + width - radius, y);
          exportCtx.quadraticCurveTo(x + width, y, x + width, y + radius);
          exportCtx.lineTo(x + width, y + height - radius);
          exportCtx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          exportCtx.lineTo(x + radius, y + height);
          exportCtx.quadraticCurveTo(x, y + height, x, y + height - radius);
          exportCtx.lineTo(x, y + radius);
          exportCtx.quadraticCurveTo(x, y, x + radius, y);
          exportCtx.closePath();
          exportCtx.fill();
          exportCtx.stroke();

          exportCtx.fillStyle = "#1f2933";
          exportCtx.font = `${16 * dpr}px "Noto Sans KR", "Pretendard", sans-serif`;
          exportCtx.textBaseline = "top";
          const lineHeight = 24 * dpr;
          const paddingX = 12 * dpr;
          const paddingY = 12 * dpr;
          const lines = body.innerText.replace(/\r/g, "").split("\n");
          lines.forEach((line, index) => {
            exportCtx.fillText(line, x + paddingX, y + paddingY + index * lineHeight, width - paddingX * 2);
          });
          exportCtx.restore();
        });

        return exportCanvas;
      };

      const exportBoardBlob = () => new Promise((resolve, reject) => {
        const exportCanvas = buildExportCanvas();
        exportCanvas.toBlob((blob) => {
          if (blob) {
            resolve({ blob });
          } else {
            reject(new Error("Failed to export whiteboard."));
          }
        }, "image/png", 0.92);
      });

      const triggerDownload = (blob, filename = `whiteboard-${Date.now()}.png`) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      };

      const downloadBoard = async () => {
        try {
          const { blob } = await exportBoardBlob();
          triggerDownload(blob);
        } catch (error) {
          console.error(error);
          alert("이미지를 저장하는 데 문제가 발생했습니다. 다시 시도해 주세요.");
        }
      };

      downloadButton.addEventListener("click", downloadBoard);

      const collectNoteTexts = () => {
        const noteBodies = [...textLayer.querySelectorAll(".note-body")];
        return noteBodies
          .map((el) => el.innerText.replace(/\s+/g, " ").trim())
          .filter(Boolean)
          .join("\n\n");
      };

      const formatShareText = (notesText) => {
        if (notesText) {
          const truncated = notesText.length > 500 ? `${notesText.slice(0, 497)}…` : notesText;
          return `오늘의 화이트보드 메모\n${truncated}`;
        }
        return "화이트보드 메모를 공유합니다.";
      };

      const tryWebShare = async (blob, text) => {
        if (!navigator.share) return false;
        let files = undefined;
        if (blob && typeof File !== "undefined") {
          const file = new File([blob], `whiteboard-${Date.now()}.png`, { type: "image/png" });
          files = [file];
          if (navigator.canShare && !navigator.canShare({ files })) {
            files = undefined;
          }
        }
        try {
          const shareData = {
            title: "화이트보드 메모",
            text
          };
          if (files) {
            shareData.files = files;
          }
          await navigator.share(shareData);
          return true;
        } catch (error) {
          if (error.name === "AbortError") {
            return true;
          }
          console.warn("Web Share failed:", error);
          return false;
        }
      };

      const shareButton = document.getElementById("share-button");
      const shareMenu = document.getElementById("share-menu");
      const shareWrapper = shareButton?.parentElement;
      const shareOptions = shareMenu?.querySelectorAll("button[data-share]");

      const closeShareMenu = () => {
        if (!shareMenu) return;
        shareMenu.classList.remove("open");
        shareButton?.setAttribute("aria-expanded", "false");
      };

      const openShareMenu = () => {
        if (!shareMenu) return;
        shareMenu.classList.add("open");
        shareButton?.setAttribute("aria-expanded", "true");
      };

      const toggleShareMenu = () => {
        if (!shareMenu) return;
        const isOpen = shareMenu.classList.contains("open");
        if (isOpen) {
          closeShareMenu();
        } else {
          openShareMenu();
        }
      };

      shareButton?.addEventListener("click", (event) => {
        event.stopPropagation();
        toggleShareMenu();
      });

      document.addEventListener("pointerdown", (event) => {
        if (!shareMenu?.classList.contains("open")) return;
        if (!shareWrapper?.contains(event.target)) {
          closeShareMenu();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          closeShareMenu();
        }
      });

      const handleShareSelection = async (platform) => {
        closeShareMenu();
        let blob;
        try {
          ({ blob } = await exportBoardBlob());
        } catch (error) {
          console.error(error);
          alert("공유 이미지를 준비하지 못했습니다. 잠시 후 다시 시도해 주세요.");
          return;
        }

        const notesText = collectNoteTexts();
        const shareText = formatShareText(notesText);

        const shared = await tryWebShare(blob, shareText);
        if (shared) {
          return;
        }

        if (platform === "twitter") {
          const tweetContent = notesText
            ? `${notesText}`.slice(0, 260)
            : "화이트보드 메모를 공유합니다.";
          const intentUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetContent)}`;
          window.open(intentUrl, "_blank", "noopener,noreferrer");
          return;
        }

        triggerDownload(blob);
        if (platform === "instagram") {
          alert("공유를 위한 이미지를 저장했습니다. 인스타그램 앱에서 스토리 또는 게시물로 이미지를 업로드해 주세요.");
        } else if (platform === "kakao") {
          alert("공유를 위한 이미지를 저장했습니다. 카카오톡에서 이미지를 선택해 친구에게 보내거나 스토리에 올려 보세요.");
        }
      };

      shareOptions?.forEach((button) => {
        button.addEventListener("click", () => {
          const target = button.dataset.share;
          if (!target) return;
          handleShareSelection(target);
        });
      });

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      setMode("draw");
    })();
    window.Userback = window.Userback || {};
    Userback.access_token = "A-dT8lHiMUwAo82KpSxhtKMc5Zf";
    // identify your logged-in users (optional)
    Userback.user_data = {
      id: "123456", // example data
      info: {
        name: "someone", // example data
        email: "someone@example.com" // example data
      }
    };
    (function(d) {
      var s = d.createElement('script');s.async = true;s.src = 'https://static.userback.io/widget/v1.js';(d.head || d.body).appendChild(s);
    })(document);
  </script>
</body>
</html>
